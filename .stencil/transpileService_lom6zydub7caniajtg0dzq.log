{"moduleFile":{"sourceFilePath":"/Users/alexchen/Desktop/HackNYU-2020/src/components/wallet/methods/withdrawAsset.ts","jsFilePath":"/Users/alexchen/Desktop/HackNYU-2020/src/components/wallet/methods/withdrawAsset.js","cmps":[],"coreRuntimeApis":[],"collectionName":null,"dtsFilePath":null,"excludeFromCollection":false,"externalImports":["@services/argon2","@services/error","@services/tweetnacl","axios","lodash-es","stellar-sdk"],"hasVdomAttribute":false,"hasVdomXlink":false,"hasVdomClass":false,"hasVdomFunctional":false,"hasVdomKey":false,"hasVdomListener":false,"hasVdomPropOrAttr":false,"hasVdomRef":false,"hasVdomRender":false,"hasVdomStyle":false,"hasVdomText":false,"htmlAttrNames":[],"htmlTagNames":[],"isCollectionDependency":false,"isLegacy":false,"localImports":[],"originalCollectionComponentPath":null,"originalImports":["stellar-sdk","axios","lodash-es","@services/error","@services/argon2","@services/tweetnacl"],"potentialCmpRefs":[]},"jsText":"import { Transaction, Account, TransactionBuilder, BASE_FEE, Networks, Operation, Asset, Memo, MemoHash } from 'stellar-sdk';\r\nimport axios from 'axios';\r\nimport { get as loGet, each as loEach, findIndex as loFindIndex, } from 'lodash-es';\r\nimport { handleError } from '@services/error';\r\nimport { stretchPincode } from '@services/argon2';\r\nimport { decrypt } from '@services/tweetnacl';\r\nexport default async function withdrawAsset() {\r\n    try {\r\n        let currency = await this.setPrompt({\r\n            message: 'Select the currency you\\'d like to withdraw',\r\n            options: this.toml.CURRENCIES\r\n        });\r\n        currency = currency.split(':');\r\n        const pincode = await this.setPrompt({\r\n            message: 'Enter your account pincode',\r\n            type: 'password'\r\n        });\r\n        const pincode_stretched = await stretchPincode(pincode, this.account.publicKey);\r\n        const keypair = decrypt(this.account.cipher, this.account.nonce, pincode_stretched);\r\n        const balances = loGet(this.account, 'state.balances');\r\n        const hasCurrency = loFindIndex(balances, {\r\n            asset_code: currency[0],\r\n            asset_issuer: currency[1]\r\n        });\r\n        if (hasCurrency === -1)\r\n            await this.trustAsset(currency[0], currency[1], pincode);\r\n        const info = await axios.get(`${this.toml.TRANSFER_SERVER}/info`)\r\n            .then(({ data }) => data);\r\n        console.log(info);\r\n        const auth = await axios.get(`${this.toml.WEB_AUTH_ENDPOINT}`, {\r\n            params: {\r\n                account: this.account.publicKey\r\n            }\r\n        })\r\n            .then(async ({ data: { transaction, network_passphrase } }) => {\r\n            const txn = new Transaction(transaction, network_passphrase);\r\n            this.error = null;\r\n            this.loading = Object.assign(Object.assign({}, this.loading), { withdraw: true });\r\n            txn.sign(keypair);\r\n            return txn.toXDR();\r\n        })\r\n            .then((transaction) => axios.post(`${this.toml.WEB_AUTH_ENDPOINT}`, { transaction }, { headers: { 'Content-Type': 'application/json' } }))\r\n            .then(({ data: { token } }) => token); // Store the JWT in localStorage\r\n        console.log(auth);\r\n        const formData = new FormData();\r\n        loEach({\r\n            asset_code: currency[0],\r\n            account: this.account.publicKey,\r\n            lang: 'en'\r\n        }, (value, key) => formData.append(key, value));\r\n        const interactive = await axios.post(`${this.toml.TRANSFER_SERVER}/transactions/withdraw/interactive`, formData, {\r\n            headers: {\r\n                'Authorization': `Bearer ${auth}`,\r\n                'Content-Type': 'multipart/form-data'\r\n            }\r\n        }).then(({ data }) => data);\r\n        console.log(interactive);\r\n        const transactions = await axios.get(`${this.toml.TRANSFER_SERVER}/transactions`, {\r\n            params: {\r\n                asset_code: currency[0],\r\n                limit: 1,\r\n                kind: 'withdrawal',\r\n            },\r\n            headers: {\r\n                'Authorization': `Bearer ${auth}`\r\n            }\r\n        })\r\n            .then(({ data: { transactions } }) => transactions);\r\n        console.log(transactions);\r\n        const urlBuilder = new URL(interactive.url);\r\n        urlBuilder.searchParams.set('callback', 'postMessage');\r\n        const popup = open(urlBuilder.toString(), 'popup', 'width=500,height=800');\r\n        if (!popup) {\r\n            this.loading = Object.assign(Object.assign({}, this.loading), { withdraw: false });\r\n            throw 'Popups are blocked. You\\'ll need to enable popups for this demo to work';\r\n        }\r\n        await new Promise((resolve, reject) => {\r\n            let submittedTxn;\r\n            window.onmessage = ({ data: { transaction } }) => {\r\n                console.log(transaction.status, transaction);\r\n                if (transaction.status === 'completed') {\r\n                    this.updateAccount();\r\n                    this.loading = Object.assign(Object.assign({}, this.loading), { withdraw: false });\r\n                    resolve();\r\n                }\r\n                else if (!submittedTxn\r\n                    && transaction.status === 'pending_user_transfer_start') {\r\n                    this.server\r\n                        .accounts()\r\n                        .accountId(keypair.publicKey())\r\n                        .call()\r\n                        .then(({ sequence }) => {\r\n                        const account = new Account(keypair.publicKey(), sequence);\r\n                        const txn = new TransactionBuilder(account, {\r\n                            fee: BASE_FEE,\r\n                            networkPassphrase: Networks.TESTNET\r\n                        })\r\n                            .addOperation(Operation.payment({\r\n                            destination: transaction.withdraw_anchor_account,\r\n                            asset: new Asset(currency[0], currency[1]),\r\n                            amount: transaction.amount_in\r\n                        }))\r\n                            .addMemo(new Memo(MemoHash, transaction.withdraw_memo))\r\n                            .setTimeout(0)\r\n                            .build();\r\n                        txn.sign(keypair);\r\n                        return this.server.submitTransaction(txn);\r\n                    })\r\n                        .then((res) => {\r\n                        console.log(res);\r\n                        submittedTxn = res;\r\n                        const urlBuilder = new URL(transaction.more_info_url);\r\n                        urlBuilder.searchParams.set('callback', 'postMessage');\r\n                        popup.location.href = urlBuilder.toString();\r\n                    })\r\n                        .catch((err) => reject(err));\r\n                }\r\n                else {\r\n                    setTimeout(() => {\r\n                        const urlBuilder = new URL(transaction.more_info_url);\r\n                        urlBuilder.searchParams.set('callback', 'postMessage');\r\n                        popup.location.href = urlBuilder.toString();\r\n                    }, 1000);\r\n                }\r\n            };\r\n        });\r\n    }\r\n    catch (err) {\r\n        this.loading = Object.assign(Object.assign({}, this.loading), { withdraw: false });\r\n        this.error = handleError(err);\r\n    }\r\n}\r\n"}